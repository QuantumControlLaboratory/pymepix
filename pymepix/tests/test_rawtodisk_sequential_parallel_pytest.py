# This file is part of Pymepix
#
# In all scientific work using Pymepix, please reference it as
#
# A. F. Al-Refaie, M. Johny, J. Correa, D. Pennicard, P. Svihra, A. Nomerotski, S. Trippel, and J. KÃ¼pper:
# "PymePix: a python library for SPIDR readout of Timepix3", J. Inst. 14, P10003 (2019)
# https://doi.org/10.1088/1748-0221/14/10/P10003
# https://arxiv.org/abs/1905.07999
#
# Pymepix is free software: you can redistribute it and/or modify it under the terms of the GNU
# General Public License as published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with this program. If not,
# see <https://www.gnu.org/licenses/>.

import multiprocessing
import socket
import struct
import ctypes
import os
import time
import numpy as np
import filecmp
from multiprocessing.sharedctypes import Value
from pymepix.processing.acquisition import PixelPipeline

ADDRESS = ("127.0.0.1", 50000)


def receive_and_process(parallel):
    """Setup an acquisition pipeline to receive data, then send data to receive

    Parameters
    ----------
    parallel : boolean
        Decides whether to setup the acquisition pipeline to operate in
        parallel (udpsampler > (rawtodisk || packetprocessor)) or
        sequential (udpsampler > rawtodisk > packetprocessor)

    Returns
    -------
    string
        Name of the raw output file generated by the rawtodisk process
    """

    q = multiprocessing.Queue()
    l = Value(ctypes.c_int, 1)
    if parallel:
        acqpipeline_seq = PixelPipeline(data_queue=q, longtime=l, address=ADDRESS, parallel=True)
    else:
        acqpipeline_seq = PixelPipeline(data_queue=q, longtime=l, address=ADDRESS, parallel=False)
    acqpipeline_seq.start()

    send_data()

    fname = acqpipeline_seq._stages[1]._pipeline_objects[0]._raw_file.name
    print(fname)
    acqpipeline_seq.stop()
    return fname


def generate_data():
    """Generate the data to send

    Returns
    -------
    np.ndarray
        Numpy array of ascending numbers
    """
    data = np.arange(12000, dtype=np.uint64)
    return data


def send_data():
    """Send data as udp packets
    """
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    data = generate_data()
    size = 1000  # chunk size of data to send
    total = int(np.floor((len(data) - size) / size))
    for i in range(total):
        a = data[(i * size):((i + 1) * size)]
        packet = struct.pack('%sQ' % size, *a)
        sock.sendto(packet, ADDRESS)
        time.sleep(0.1)


def test_compare_input_output():
    """Compare the saved input data to the output

    As the last n packets might not be saved because they might be too small,
    check only for the bytes actually written to the output
    """
    data = generate_data()
    byte_data = struct.pack('%sQ' % len(data), *data)
    sample_file_name = 'sample.raw'
    sample_file = open(sample_file_name, 'wb')
    sample_file.write(byte_data)
    sample_file.close()

    sequential_output = receive_and_process(parallel=False)
    assert os.stat(sample_file_name).st_size == os.stat(sequential_output).st_size, \
        "input and output should have same size"
    assert filecmp.cmp(sample_file_name, sequential_output), "input and output should be identical"

    os.remove(sample_file_name)
    os.remove(sequential_output)


def test_compare_raw_output():
    """Setup two PixelPipelines, first sequential, second parallel.
    Compare the two raw output files for equality
    """
    sequential_output = receive_and_process(parallel=False)
    parallel_output = receive_and_process(parallel=True)

    assert os.path.getsize(sequential_output) > 0
    assert os.path.getsize(parallel_output) > 0
    assert filecmp.cmp(parallel_output, sequential_output), \
        "sequential and parallel processing should result the same output"

    os.remove(sequential_output)
    os.remove(parallel_output)


if __name__ == "__main__":
    test_compare_input_output()
    test_compare_raw_output()